<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>弹幕密度示例</title>
  <!-- 引入 Chart.js（示例使用cdn） -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      margin: 0; 
      padding: 0; 
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 10px;
      background: #333;
      color: #fff;
    }
    main {
      flex: 1; 
      display: flex;
      overflow: hidden;
    }
    /* 左侧控制面板 */
    #left-panel {
      width: 220px;
      border-right: 1px solid #ccc;
      padding: 10px;
      overflow-y: auto;
      background: #f1f1f1;
    }
    #left-panel h2 {
      margin-top: 0;
    }
    #left-panel input[type="search"] {
      width: 100%;
      box-sizing: border-box;
    }
    #left-panel .section {
      margin-bottom: 10px;
    }

    /* 中间弹幕区域 + 图表 */
    #center-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #chart-container {
      height: 200px; 
      border-bottom: 1px solid #ccc;
      padding: 10px;
      background: #fafafa;
    }
    #chart-container canvas {
      width: 100%; 
      height: 100%;
    }

    /* 弹幕列表区 */
    #danmu-list {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      background: #fff;
    }
    .danmu-line {
      margin: 5px 0;
      padding: 2px;
      transition: background 0.2s;
    }
    .danmu-line:hover {
      background: #f0f8ff;
    }
    .time-label {
      color: #666;
      margin-right: 8px;
      font-size: 0.9em;
    }
    .highlight {
      background: yellow;
    }

    /* 右侧彩条 */
    #right-panel {
      width: 40px; 
      border-left: 1px solid #ccc;
      background: #eee;
      display: flex;
      flex-direction: column;
      cursor: pointer;
    }
    .density-segment {
      width: 100%;
      height: 10px;
    }

    footer {
      padding: 5px;
      background: #ddd;
      text-align: center;
    }
  </style>
</head>
<body>

<header>
  <h1>弹幕密度图 + 流式示例</h1>
</header>

<main>
  <!-- 左侧控制面板 -->
  <div id="left-panel">
    <div class="section">
      <h2>加载XML</h2>
      <input type="file" id="xmlFile" accept=".xml"/>
      <button onclick="onLoadFile()">加载</button>

      <br/><br/>
      <input type="text" id="xmlUrl" placeholder="https://example.com/danmu.xml" size="20"/>
      <button onclick="onLoadUrl()">加载</button>
    </div>

    <div class="section">
      <h2>搜索</h2>
      <input type="search" id="searchText" placeholder="输入关键词"/>
      <button onclick="doSearch()">搜索</button>
      <button onclick="clearSearch()">重置</button>
    </div>

    <div class="section">
      <h2>播放控制</h2>
      <button onclick="startPlayback()">开始播放</button>
      <button onclick="pausePlayback()">暂停</button>
      <button onclick="resumePlayback()">恢复</button>
      <button onclick="rewind()">回到开头</button>
      <br/><br/>
      <label>速度(ms/条)：</label>
      <input type="range" min="100" max="2000" step="100" value="1000" oninput="changeSpeed(this.value)">
      <span id="speedDisplay">1000</span>
    </div>

    <div class="section" id="errorMsg" style="color:red;"></div>
  </div>

  <!-- 中间区域：图表 + 弹幕列表 -->
  <div id="center-panel">
    <div id="chart-container">
      <canvas id="densityChart"></canvas>
    </div>
    <div id="danmu-list"></div>
  </div>

  <!-- 右侧：弹幕密度彩条 -->
  <div id="right-panel"></div>
</main>

<footer>
  <span>简单示例，点击图表或右侧彩带可跳转时间</span>
</footer>

<script>
/** -------------- 全局变量 -------------- */
let danmuData = [];      // 原始弹幕数据 {time, text}
let filteredData = [];   // 搜索或其他过滤后的弹幕
let buckets = [];        // 分桶后的弹幕密度 { start, end, count }

let currentIndex = 0;    // 当前播放到 filteredData 的索引
let isPlaying = false;
let timer = null;
let speed = 1000;        // 默认 1000ms / 条弹幕

// Chart.js 对象
let densityChart = null;

// 仅渲染前后多少条弹幕
const RENDER_RANGE = 20;

// ============== 加载与解析 XML ==============

function onLoadFile() {
  const fileInput = document.getElementById('xmlFile');
  const file = fileInput.files[0];
  if (!file) {
    showError('请选择XML文件');
    return;
  }
  clearError();
  const reader = new FileReader();
  reader.onload = e => {
    const xmlStr = e.target.result;
    handleXml(xmlStr);
  };
  reader.onerror = () => showError('文件读取失败');
  reader.readAsText(file, 'utf-8');
}

function onLoadUrl() {
  const url = document.getElementById('xmlUrl').value.trim();
  if (!url) {
    showError('请输入url');
    return;
  }
  clearError();
  fetch(url)
    .then(resp => {
      if (!resp.ok) {
        throw new Error(`HTTP错误：${resp.status}`);
      }
      return resp.text();
    })
    .then(xmlStr => {
      handleXml(xmlStr);
    })
    .catch(err => showError('加载失败:' + err.message));
}

function handleXml(xmlStr) {
  try {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlStr, 'application/xml');
    if (xmlDoc.querySelector('parsererror')) {
      throw new Error('XML解析失败');
    }
    // 提取 <d> 节点
    const dNodes = xmlDoc.getElementsByTagName('d');
    danmuData = [];
    for (let i=0; i<dNodes.length; i++) {
      const dEl = dNodes[i];
      const pAttr = dEl.getAttribute('p') || '';
      const text = dEl.textContent || '';
      let timeVal = 0;
      const parts = pAttr.split(',');
      if (parts[0]) {
        const t = parseFloat(parts[0]);
        if (!isNaN(t)) timeVal = t;
      }
      danmuData.push({ time: timeVal, text: text });
    }
    // 按时间升序排序
    danmuData.sort((a,b)=>a.time - b.time);

    // 重置搜索 & 播放
    filteredData = danmuData.slice(); // 初始不过滤
    resetPlayback();

    // 统计分桶
    buckets = makeBuckets(danmuData, 10); // 10秒为一桶
    renderDensityChart(buckets);
    renderDensityBar(buckets);

    clearError();
    if (danmuData.length === 0) {
      showError('未找到任何弹幕');
    }
  } catch (err) {
    showError('XML处理失败:' + err.message);
  }
}

// ============== 搜索功能 ==============
function doSearch() {
  const kw = document.getElementById('searchText').value.trim();
  if (!kw) {
    // 无输入则恢复全部
    filteredData = danmuData.slice();
    resetPlayback();
    return;
  }
  filteredData = danmuData.filter(item => item.text.includes(kw));
  resetPlayback();
}
function clearSearch() {
  document.getElementById('searchText').value = '';
  filteredData = danmuData.slice();
  resetPlayback();
}

// ============== 分桶统计 ==============
function makeBuckets(data, bucketSize=10) {
  // bucketSize=10 表示每10秒为一段
  if (!data || data.length===0) return [];
  const minT = data[0].time;
  const maxT = data[data.length-1].time;
  const nBuckets = Math.ceil((maxT-minT)/bucketSize);
  const result = [];
  for(let i=0; i<nBuckets; i++){
    const start = minT + i*bucketSize;
    result.push({ 
      start: start, 
      end: start+bucketSize,
      count: 0
    });
  }
  // 统计
  data.forEach(item=>{
    const idx = Math.floor((item.time - minT)/bucketSize);
    if (idx>=0 && idx<result.length) {
      result[idx].count++;
    }
  });
  return result;
}

// ============== 绘制折线图 (Chart.js) ==============
function renderDensityChart(buckets) {
  const ctx = document.getElementById('densityChart').getContext('2d');
  if (densityChart) {
    densityChart.destroy();
  }
  const labels = buckets.map(b=>b.start.toFixed(0)+'s~');
  const counts = buckets.map(b=>b.count);

  densityChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: '弹幕数量',
        data: counts,
        borderColor: '#409eff',
        backgroundColor: 'rgba(64,158,255, 0.2)'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      onClick: (evt, elements) => {
        // 点击获取最近的点
        if (!elements || !elements.length) return;
        const idx = elements[0].index;
        const bucket = buckets[idx];
        // 跳转到该桶起始时间
        jumpToTime(bucket.start);
      },
      scales: {
        x: { title: { display:true, text:'时间段(秒)' } },
        y: { title: { display:true, text:'弹幕数' } }
      },
      plugins: {
        legend: { display:false }
      }
    }
  });
}

// ============== 绘制右侧彩色条 ==============
function renderDensityBar(buckets) {
  const rightPanel = document.getElementById('right-panel');
  rightPanel.innerHTML = '';
  if (!buckets || buckets.length===0) return;

  // 找到最大弹幕数
  const maxCount = Math.max(...buckets.map(b=>b.count));

  buckets.forEach((b, idx)=>{
    const div = document.createElement('div');
    div.className = 'density-segment';
    // 计算颜色深度: 以count/maxCount为参考
    const ratio = (maxCount>0) ? b.count/maxCount : 0;
    const colorVal = Math.floor(255 - ratio*150); 
    // 设一个从 #FFFFFF -> #55aaaa 的渐变(示例)
    div.style.backgroundColor = `rgb(255,${colorVal},${colorVal})`;
    div.style.flex = 1; // 平分垂直空间

    div.onclick = ()=>{ jumpToTime(b.start); };
    rightPanel.appendChild(div);
  });
}

// ============== 时间跳转 & 弹幕渲染 ==============
let currentTime = 0;

function jumpToTime(t) {
  // 找到在 filteredData 中最接近 time==t 的索引
  const idx = filteredData.findIndex(item => item.time>=t);
  if (idx === -1) {
    // 大于所有弹幕时间，则跳到最后
    currentIndex = filteredData.length;
    currentTime = (filteredData.length>0)?filteredData[filteredData.length-1].time : 0;
  } else {
    currentIndex = idx;
    currentTime = filteredData[idx].time;
  }
  renderDanmuList();
}

// 只渲染当前Index附近 RENDER_RANGE 条
function renderDanmuList() {
  const container = document.getElementById('danmu-list');
  container.innerHTML = '';

  if (filteredData.length===0) {
    container.innerHTML = '<p>无弹幕</p>';
    return;
  }
  // 在 currentIndex 附近 ± RENDER_RANGE
  const start = Math.max(0, currentIndex - RENDER_RANGE);
  const end   = Math.min(filteredData.length, currentIndex + RENDER_RANGE);

  for (let i=start; i<end; i++){
    const item = filteredData[i];
    const line = document.createElement('div');
    line.className = 'danmu-line';
    line.innerHTML = `<span class="time-label">[${item.time.toFixed(2)}s]</span> ${highlightIfNeeded(item.text)}`;
    container.appendChild(line);
  }
}

// 搜索高亮
function highlightIfNeeded(text) {
  const kw = document.getElementById('searchText').value.trim();
  if (!kw) return text;
  // 简单的包含替换
  return text.replaceAll(kw, `<span class="highlight">${kw}</span>`);
}

// ============== 流式播放示例 ==============
function startPlayback() {
  resetPlayback();
  if (filteredData.length===0) {
    showError('无弹幕数据');
    return;
  }
  isPlaying = true;
  timer = setInterval(playNext, speed);
}

function pausePlayback() {
  isPlaying = false;
  stopTimer();
}

function resumePlayback() {
  if (!isPlaying && filteredData.length>0 && currentIndex<filteredData.length) {
    isPlaying = true;
    timer = setInterval(playNext, speed);
  }
}

function rewind() {
  resetPlayback();
}

function resetPlayback() {
  stopTimer();
  isPlaying = false;
  currentIndex = 0;
  currentTime = 0;
  renderDanmuList();
}

function playNext() {
  if (currentIndex >= filteredData.length) {
    stopTimer();
    isPlaying = false;
    return;
  }
  // 显示当前这条，并索引+1
  currentTime = filteredData[currentIndex].time;
  currentIndex++;
  renderDanmuList();
}

function stopTimer() {
  if (timer) {
    clearInterval(timer);
    timer = null;
  }
}

// ============== 播放速度 ==============
function changeSpeed(val) {
  speed = parseInt(val,10);
  document.getElementById('speedDisplay').textContent = speed;
  if (isPlaying) {
    // 重启定时器
    stopTimer();
    timer = setInterval(playNext, speed);
  }
}

// ============== 工具函数 ==============
function showError(msg){
  document.getElementById('errorMsg').textContent = msg;
}
function clearError(){
  document.getElementById('errorMsg').textContent = '';
}
</script>

</body>
</html>
