<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Danmaku Analysis</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    /* Toolbar layouts */
    .toolbar { margin-bottom: 10px; }
    .toolbar label { margin-right: 5px; font-weight: bold; }
    .toolbar input[type="text"] { width: 300px; padding: 3px; }
    .toolbar input[type="file"] { padding: 3px; }
    .toolbar button { margin-right: 10px; padding: 5px 10px; }
    .toolbar select { margin: 0 10px 0 5px; padding: 3px; }
    /* Comment list container */
    #commentContainer { 
      border: 1px solid #ccc; padding: 5px; 
      height: 400px; overflow-y: auto; 
      background: #fafafa;
    }
    #commentList li { line-height: 1.5em; padding: 2px 5px; }
    #commentList li .time { color: #888; width: 60px; display: inline-block; }
    #commentList li.current { background: #ffffcc; }  /* highlighted comment */
    /* Hidden state for search filtering */
    .hidden { display: none !important; }
    /* Error message style */
    #errorMsg { color: red; margin-top: 5px; }
    /* Back to search button */
    #backBtn { display: none; margin-left: 10px; }
    /* Density chart container */
    #densityChart { width: 100%; height: 200px; margin-top: 10px; }
    /* Word cloud overlay */
    #wordCloudOverlay {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 999;
    }
    #wordCloudOverlay #wordCloud {
      position: relative;
      width: 80%; height: 80%;
      margin: 5% auto; background: #fff; border: 1px solid #ccc;
    }
    #closeWordCloudBtn {
      position: absolute; top: 10px; right: 10px;
      padding: 3px 8px;
    }
    #copyMsg {
      position: absolute; bottom: 10px; width: 100%; text-align: center;
      color: green; font-weight: bold; display: none;
    }
  </style>
</head>
<body>

  <!-- Toolbar: File and URL Loading -->
  <div class="toolbar">
    <label for="fileInput">XML文件:</label>
    <input type="file" id="fileInput" accept=".xml" />
    <button id="loadFileBtn">加载</button>
    <label for="urlInput" style="margin-left:20px;">XML链接:</label>
    <input type="text" id="urlInput" placeholder="输入XML地址" />
    <button id="loadUrlBtn">加载</button>
    <div id="errorMsg"></div>
  </div>

  <!-- Toolbar: Search and Word Cloud -->
  <div class="toolbar">
    <label for="searchInput">搜索:</label>
    <input type="text" id="searchInput" placeholder="多关键词用空格分隔" />
    <label><input type="radio" name="searchMode" value="AND" id="andMode"> 所有词</label>
    <label><input type="radio" name="searchMode" value="OR" id="orMode" checked> 任意词</label>
    <button id="searchBtn">搜索</button>
    <button id="wordCloudBtn">词云</button>
    <button id="backBtn">返回搜索结果</button>
  </div>

  <!-- Toolbar: Playback controls -->
  <div class="toolbar">
    <button id="playPauseBtn">播放</button>
    <label for="speedSelect">速度:</label>
    <select id="speedSelect">
      <option value="0.5">0.5x</option>
      <option value="1" selected>1x</option>
      <option value="1.5">1.5x</option>
      <option value="2">2x</option>
      <option value="4">4x</option>
    </select>
    <label for="jumpInput">跳转到:</label>
    <input type="text" id="jumpInput" placeholder="秒数或hh:mm:ss" style="width:100px;" />
    <button id="jumpBtn">跳转</button>
  </div>

  <!-- Comment list container -->
  <div id="commentContainer">
    <ul id="commentList"></ul>
  </div>

  <!-- Density line chart container -->
  <div id="densityChart"></div>

  <!-- Word Cloud Overlay -->
  <div id="wordCloudOverlay">
    <div id="wordCloud">
      <button id="closeWordCloudBtn">关闭</button>
      <div id="copyMsg">词已复制</div>
    </div>
  </div>

  <!-- Include ECharts and ECharts WordCloud via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"></script>

  <script>
    // Global data structures
    let bulletList = [];        // Array of {time, text, textLower}
    let chartDensity = null;    // ECharts instance for density chart
    let densityDataFull = [];   // Full density data (counts per second)
    let densityDataFiltered = [];// Filtered density data for search results
    let wordCloudChart = null;  // ECharts instance for word cloud
    let searchQueryLast = "";   // Last search query
    let searchModeLast = "OR";  // Last search mode

    // Playback state
    let isPlaying = false;
    let playbackSpeed = 1;
    let currentTime = 0;
    let currentIndex = 0;      // index in bulletList for next comment to show
    let playInterval = null;
    let autoScroll = true;
    let programmaticScroll = false;
    let autoScrollTimer = null;

    // Stop words list (common meaningless words to filter out from word cloud)
    const stopWords = new Set([
      "的","了","和","是","我","你","他","她","它",
      "吗","吧","啊","哦","嗯","在","也","不","就","都",
      "也许","但是","因为","所以","如果",
      " ", "",  // empty/space
    ]);

    // Utility: Parse time input (seconds or hh:mm:ss)
    function parseTimeInput(input) {
      input = input.trim();
      if (!input) return null;
      if (input.indexOf(":") >= 0) {
        // Format with colon
        let parts = input.split(":");
        if (parts.length === 2) {
          // mm:ss
          let mm = parseInt(parts[0], 10);
          let ss = parseInt(parts[1], 10);
          if (isNaN(mm) || isNaN(ss)) return null;
          return mm * 60 + ss;
        } else if (parts.length === 3) {
          // hh:mm:ss
          let hh = parseInt(parts[0], 10);
          let mm = parseInt(parts[1], 10);
          let ss = parseInt(parts[2], 10);
          if (isNaN(hh) || isNaN(mm) || isNaN(ss)) return null;
          return hh * 3600 + mm * 60 + ss;
        } else {
          return null;
        }
      } else {
        // Plain seconds
        let sec = parseInt(input, 10);
        return isNaN(sec) ? null : sec;
      }
    }

    // Utility: Format seconds to hh:mm:ss (for display if needed)
    function formatTime(sec) {
      let h = Math.floor(sec / 3600);
      let m = Math.floor((sec % 3600) / 60);
      let s = sec % 60;
      return (h > 0 ? String(h).padStart(2,"0") + ":" : "") +
             String(m).padStart(2,"0") + ":" +
             String(s).padStart(2,"0");
    }

    // Load XML from text (called after file read or fetch)
    function loadXmlData(xmlText) {
      // Parse the XML text to a document
      let parser = new DOMParser();
      let xmlDoc;
      try {
        xmlDoc = parser.parseFromString(xmlText, "text/xml");
      } catch (e) {
        showError("XML解析失败。");
        return;
      }
      if (!xmlDoc) {
        showError("XML解析失败。");
        return;
      }
      // Extract <d> elements (assuming bilibili XML format)
      const dElems = xmlDoc.getElementsByTagName("d");
      bulletList = [];
      for (let d of dElems) {
        let pAttr = d.getAttribute("p");
        let text = d.textContent || "";
        if (!pAttr) continue;
        // The first value in p attribute is the time in seconds (could be float)
        let timeSec = parseFloat(pAttr.split(",")[0]);
        if (isNaN(timeSec)) continue;
        let time = Math.floor(timeSec);
        bulletList.push({
          time: time,
          text: text,
          textLower: text.toLowerCase()
        });
      }
      // Sort bulletList by time (just in case it's not sorted)
      bulletList.sort((a, b) => a.time - b.time);

      // Build the comment list in the DOM
      const ul = document.getElementById("commentList");
      ul.innerHTML = "";  // clear any existing
      for (let i = 0; i < bulletList.length; i++) {
        const li = document.createElement("li");
        li.innerHTML = `<span class="time">[${formatTime(bulletList[i].time)}]</span> ` +
                       `<span class="text">${bulletList[i].text}</span>`;
        li.addEventListener("click", () => {
          // Click on a comment in list: jump to that time
          jumpToTime(bulletList[i].time);
        });
        ul.appendChild(li);
      }

      // Prepare density chart data (full)
      computeDensityFull();
      renderDensityChart(densityDataFull);

      // Prepare word cloud data
      computeWordFrequencies();

      // Reset playback state
      resetPlayback();
      // Clear any previous error message
      showError(""); 

      // If a previous search query exists (from a prior load), clear it
      clearSearch();
    }

    // Compute full density data (counts per second for all comments)
    function computeDensityFull() {
      if (bulletList.length === 0) {
        densityDataFull = [];
        return;
      }
      let maxTime = bulletList[bulletList.length - 1].time;
      densityDataFull = new Array(maxTime + 1).fill(0);
      for (let bullet of bulletList) {
        if (bullet.time >= 0 && bullet.time < densityDataFull.length) {
          densityDataFull[bullet.time] += 1;
        }
      }
    }

    // Compute density data for filtered search results (based on searchQueryLast and searchModeLast)
    function computeDensityFiltered(matches) {
      // Create an array of same length as full density, filled with 0
      densityDataFiltered = new Array(densityDataFull.length).fill(0);
      for (let idx of matches) {
        let t = bulletList[idx].time;
        densityDataFiltered[t] += 1;
      }
    }

    // Initialize or update density chart with given data
    function renderDensityChart(dataArray) {
      const chartDiv = document.getElementById('densityChart');
      if (!chartDensity) {
        // initialize chart
        chartDensity = echarts.init(chartDiv);
        const option = {
          tooltip: { trigger: 'axis' },
          xAxis: {
            type: 'category',
            data: dataArray.map((_, i) => i),  // categories as seconds
            axisLabel: {
              formatter: function (value) {
                // show as mm:ss
                let sec = parseInt(value);
                let m = Math.floor(sec/60), s = sec % 60;
                return (m < 10 ? "0"+m : m) + ":" + (s < 10 ? "0"+s : s);
              }
            }
          },
          yAxis: { type: 'value', name: '弹幕数' },
          series: [{
            name: '弹幕密度',
            type: 'line',
            data: dataArray,
            smooth: true,
            areaStyle: {}
          }]
        };
        chartDensity.setOption(option);
        // Add click event for jumping to time
        chartDensity.on('click', function(params) {
          if (params && params.dataIndex != null) {
            let sec = params.dataIndex;
            jumpToTime(sec);
          }
        });
      } else {
        // update existing chart data
        chartDensity.setOption({
          series: [{ data: dataArray }]
        });
      }
    }

    // Compute word frequencies and initialize word cloud (do this after loading)
    let wordCloudData = [];
    function computeWordFrequencies() {
      const freq = new Map();
      for (let bullet of bulletList) {
        // Split text by non-alphanumeric/Chinese characters
        let text = bullet.text;
        // Replace punctuation with space
        let words = text.replace(/[^\p{L}\p{N}]+/ug, ' ').trim().split(/\s+/);
        for (let w of words) {
          if (!w) continue;
          // Filter out very short tokens (length 1) and stop words
          if (w.length === 1 && stopWords.has(w)) continue;
          if (stopWords.has(w.toLowerCase())) continue;
          // Convert to lowercase for consistency (mostly for alphabetic words)
          let key = w.toLowerCase();
          freq.set(key, (freq.get(key) || 0) + 1);
        }
      }
      // Sort by frequency and take top 100
      wordCloudData = Array.from(freq.entries())
                           .map(([name, value]) => ({ name, value }))
                           .sort((a, b) => b.value - a.value)
                           .slice(0, 100);
      // Initialize word cloud chart if not already
      if (!wordCloudChart) {
        const wcDiv = document.getElementById('wordCloud');
        wordCloudChart = echarts.init(wcDiv);
        const option = {
          tooltip: {},
          series: [{
            type: 'wordCloud',
            gridSize: 8,
            sizeRange: [12, 60],
            rotationRange: [0, 0], // no rotation, all horizontal
            textStyle: {
              color: function() {
                // random color for each word
                return 'rgb(' + [
                  Math.round(Math.random() * 160),
                  Math.round(Math.random() * 160),
                  Math.round(Math.random() * 160)
                ].join(',') + ')';
              }
            },
            data: wordCloudData
          }]
        };
        wordCloudChart.setOption(option);
        // Click event for copying word
        wordCloudChart.on('click', function(params) {
          if (params.data && params.data.name) {
            copyToClipboard(params.data.name);
          }
        });
      } else {
        // Update data if chart already exists (e.g., reloading a new file)
        wordCloudChart.setOption({
          series: [{ data: wordCloudData }]
        });
      }
    }

    // Copy text to clipboard (with fallback) and show confirmation
    function copyToClipboard(text) {
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
          showCopyMessage();
        }).catch(err => {
          console.error("Clipboard copy failed:", err);
          showCopyMessage();
        });
      } else {
        // Fallback for older browsers
        const textarea = document.createElement("textarea");
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        try {
          document.execCommand('copy');
        } catch (err) {
          console.error("execCommand copy failed:", err);
        }
        document.body.removeChild(textarea);
        showCopyMessage();
      }
    }

    function showCopyMessage() {
      const msg = document.getElementById('copyMsg');
      msg.style.display = 'block';
      setTimeout(() => { msg.style.display = 'none'; }, 1500);
    }

    // Show or clear error message
    function showError(msg) {
      const errDiv = document.getElementById("errorMsg");
      if (!msg) {
        errDiv.style.display = "none";
      } else {
        errDiv.textContent = msg;
        errDiv.style.display = "block";
      }
    }

    // Reset playback state to beginning (called after loading a new XML)
    function resetPlayback() {
      clearInterval(playInterval);
      isPlaying = false;
      currentTime = 0;
      currentIndex = 0;
      document.getElementById("playPauseBtn").textContent = "播放";
      // Remove any highlight
      const listItems = document.querySelectorAll("#commentList li");
      listItems.forEach(li => li.classList.remove("current"));
      // Reset autoScroll
      autoScroll = true;
      programmaticScroll = false;
    }

    // Play/Pause toggle
    function togglePlayPause() {
      if (!isPlaying) {
        // Start playback
        if (currentIndex >= bulletList.length) {
          // If at end, restart
          currentTime = 0;
          currentIndex = 0;
        }
        isPlaying = true;
        document.getElementById("playPauseBtn").textContent = "暂停";
        // Use a small interval tick for timing
        let intervalMs = 100;
        clearInterval(playInterval);
        playInterval = setInterval(() => {
          currentTime += (intervalMs / 1000) * playbackSpeed;
          // While there are comments whose time <= currentTime, show them
          while (currentIndex < bulletList.length && bulletList[currentIndex].time <= Math.floor(currentTime)) {
            showComment(currentIndex);
            currentIndex++;
            if (currentIndex >= bulletList.length) break;
          }
          if (currentIndex >= bulletList.length) {
            // reached end
            clearInterval(playInterval);
            isPlaying = false;
            document.getElementById("playPauseBtn").textContent = "播放";
          }
        }, intervalMs);
      } else {
        // Pause playback
        isPlaying = false;
        document.getElementById("playPauseBtn").textContent = "播放";
        clearInterval(playInterval);
      }
    }

    // Highlight and center the comment at the given index
    function showComment(index) {
      const ul = document.getElementById("commentList");
      const listItems = ul.getElementsByTagName("li");
      if (!listItems[index]) return;
      // Remove previous highlight
      const prev = ul.querySelector("li.current");
      if (prev) prev.classList.remove("current");
      // Highlight this comment
      const li = listItems[index];
      li.classList.add("current");
      // Auto-scroll into view if enabled
      if (autoScroll) {
        programmaticScroll = true;
        li.scrollIntoView({ behavior: 'instant', block: 'center' });
      }
    }

    // Handle manual scroll events on comment list to enable/disable autoScroll
    document.getElementById("commentContainer").addEventListener("scroll", () => {
      if (programmaticScroll) {
        // If this scroll was initiated by our code, ignore it
        programmaticScroll = false;
        return;
      }
      // User scrolled manually, disable autoScroll temporarily
      autoScroll = false;
      clearTimeout(autoScrollTimer);
      autoScrollTimer = setTimeout(() => {
        autoScroll = true;
      }, 5000);
    });

    // Jump to a specific time (in seconds)
    function jumpToTime(targetSec) {
      if (bulletList.length === 0) return;
      // Find the index of the first comment at or after targetSec
      let idx = bulletList.findIndex(b => b.time >= targetSec);
      if (idx === -1) {
        idx = bulletList.length - 1; // if target beyond last comment, go to last
      }
      // Update playback state
      currentTime = bulletList[idx].time;
      currentIndex = idx;
      // Highlight that comment immediately
      showComment(idx);
      // If we were in search mode (filtered), leaving search to show full context
      if (searchQueryLast && document.getElementById("backBtn").style.display === "none") {
        // If currently showing filtered list, clear filter to show context
        clearSearchFilter();
        // Show back-to-search button
        document.getElementById("backBtn").style.display = "inline-block";
      }
    }

    // Apply search filter based on current input and mode
    function applySearch() {
      const query = document.getElementById("searchInput").value.toLowerCase().trim();
      const mode = document.querySelector("input[name='searchMode']:checked").value;
      searchQueryLast = query;
      searchModeLast = mode;
      const listItems = document.querySelectorAll("#commentList li");
      let matchIndices = [];
      if (!query) {
        // Empty query -> show all
        listItems.forEach(li => li.classList.remove("hidden"));
      } else {
        const keywords = query.split(/\s+/).filter(k => k);
        listItems.forEach((li, idx) => {
          const text = bulletList[idx].textLower;
          let isMatch;
          if (mode === "AND") {
            isMatch = keywords.every(kw => text.includes(kw));
          } else { // OR
            isMatch = keywords.some(kw => text.includes(kw));
          }
          if (isMatch) {
            li.classList.remove("hidden");
            matchIndices.push(idx);
          } else {
            li.classList.add("hidden");
          }
        });
      }
      // Update density chart for filtered results
      if (!query) {
        renderDensityChart(densityDataFull);
      } else {
        computeDensityFiltered(matchIndices);
        renderDensityChart(densityDataFiltered);
      }
    }

    // Clear search filter and show full list (used when leaving search results)
    function clearSearchFilter() {
      const listItems = document.querySelectorAll("#commentList li");
      listItems.forEach(li => li.classList.remove("hidden"));
      renderDensityChart(densityDataFull);
    }

    // Clear search input and state (used when loading new XML or explicitly clearing search)
    function clearSearch() {
      document.getElementById("searchInput").value = "";
      document.getElementById("andMode").checked = false;
      document.getElementById("orMode").checked = true;
      searchQueryLast = "";
      searchModeLast = "OR";
      document.getElementById("backBtn").style.display = "none";
    }

    // Event handlers for UI controls
    document.getElementById("loadFileBtn").addEventListener("click", () => {
      const fileInput = document.getElementById("fileInput");
      if (fileInput.files.length === 0) {
        showError("请选择一个XML文件。");
        return;
      }
      const file = fileInput.files[0];
      const reader = new FileReader();
      reader.onload = () => {
        loadXmlData(reader.result);
      };
      reader.onerror = () => {
        showError("文件读取失败。");
      };
      reader.readAsText(file);
    });

    document.getElementById("loadUrlBtn").addEventListener("click", () => {
      const url = document.getElementById("urlInput").value.trim();
      if (!url) {
        showError("请输入XML链接。");
        return;
      }
      fetch(url).then(response => {
        if (!response.ok) throw new Error("网络错误");
        return response.text();
      }).then(text => {
        loadXmlData(text);
      }).catch(err => {
        console.error(err);
        showError("XML加载失败，请检查链接或网络。");
      });
    });

    document.getElementById("playPauseBtn").addEventListener("click", () => {
      if (bulletList.length === 0) return;
      togglePlayPause();
    });

    document.getElementById("speedSelect").addEventListener("change", (e) => {
      playbackSpeed = parseFloat(e.target.value);
    });

    document.getElementById("jumpBtn").addEventListener("click", () => {
      const val = document.getElementById("jumpInput").value;
      const sec = parseTimeInput(val);
      if (sec !== null) {
        jumpToTime(sec);
      }
    });

    document.getElementById("searchBtn").addEventListener("click", () => {
      applySearch();
      // Hide back-to-search button (new search resets context)
      document.getElementById("backBtn").style.display = "none";
    });

    document.getElementById("backBtn").addEventListener("click", () => {
      // Re-apply the last search filter (which should still be in input and radios)
      applySearch();
      // Hide the back button after returning to search view
      document.getElementById("backBtn").style.display = "none";
    });

    document.getElementById("wordCloudBtn").addEventListener("click", () => {
      if (!wordCloudChart) {
        // If no word cloud data (perhaps no file loaded), do nothing
        return;
      }
      // Show word cloud overlay
      document.getElementById("wordCloudOverlay").style.display = "block";
      // You may call resize on chart in case container size changed
      wordCloudChart.resize();
    });

    document.getElementById("closeWordCloudBtn").addEventListener("click", () => {
      document.getElementById("wordCloudOverlay").style.display = "none";
    });
  </script>
</body>
</html>
